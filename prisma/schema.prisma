generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// CORE MODELS
// ============================================

model Company {
  id String @id @default(uuid())
  name String
  domain String 
  active Boolean @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  users User[]
  companySettings CompanySettings?
  
  // Knowledge
  knowledgeNodes KnowledgeNode[]
  knowledgeLinks KnowledgeLink[]
  knowledgeEmbeddings KnowledgeEmbedding[]
  knowledgeSuggestions KnowledgeSuggestion[]
  
  // Skills & Learning
  skills Skill[]
  learningPaths LearningPath[]
  skillDevelopmentPlans SkillDevelopmentPlan[]
  
  // CRM
  contacts Contact[]
  deals Deal[]
  interactions Interaction[]
  
  // ERP
  products Product[]
  invoices Invoice[]
  expenses Expense[]
  suppliers Supplier[]
  
  // Chat
  channels Channel[]
  messages Message[]
  directConversations DirectConversation[]
  
  // Omnichannel
  whatsappAccounts WhatsAppAccount[]
  conversations Conversation[]
  conversationAssignments ConversationAssignment[]
  
  // Notifications
  notifications Notification[]
  
  // Sync/Integration
  integrationConnections IntegrationConnection[]
  syncRuns SyncRun[]
  externalEntityMaps ExternalEntityMap[]
  
  // Analytics
  eventLogs EventLog[]
  
  // Files
  files File[]
  
  // Audit
  auditLogs AuditLog[]
  
  // Webhooks
  webhookSubscriptions WebhookSubscription[]
  
  // API Keys
  apiKeys ApiKey[]

  // Automations (NEW)
  workflows Workflow[]

  // Gatekeeper (NEW)
  companyPolicy CompanyPolicy?
  gatekeeperLogs GatekeeperLog[]

  // Cognitive OS (NEW)
  employeeGaps EmployeeGap[]
  simulationScenarios SimulationScenario[]

  // Reminders (NEW)
  reminders Reminder[]

  @@unique([domain])
  @@map("companies")
}

model User {
  id String @id @default(uuid())
  companyId String
  email String
  passwordHash String
  name String
  role String
  active Boolean @default(true)
  twoFactorSecret String?
  lastLogin DateTime?
  avatar String?
  timezone String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  
  // Knowledge
  createdNodes KnowledgeNode[]
  knowledgeSuggestions KnowledgeSuggestion[]
  
  // Skills
  employeeSkills EmployeeSkill[]
  skillDevelopmentPlans SkillDevelopmentPlan[]
  
  // Learning
  learningEnrollments LearningEnrollment[]
  learningProgresses LearningProgress[]
  
  // CRM
  ownedContacts Contact[] @relation("ContactOwner")
  ownedDeals Deal[] @relation("DealOwner")
  interactions Interaction[]
  
  // ERP
  expenses Expense[]
  stockMovements StockMovement[]
  
  // Chat
  channelMembers ChannelMember[]
  messages Message[]
  messageReactions MessageReaction[]
  directConversationMembers DirectConversationMember[]
  
  // Omnichannel
  assignedConversations ConversationAssignment[]
  conversationNotes ConversationNote[]
  
  // Notifications
  notifications Notification[]
  
  // Analytics
  eventLogs EventLog[]
  
  // Files
  files File[]
  
  // Audit
  auditLogs AuditLog[]
  
  // OAuth
  oauthAccounts OAuthAccount[]
  
  // API Keys
  createdApiKeys ApiKey[] @relation("ApiKeyCreator")

  // Gatekeeper (NEW)
  attentionProfile AttentionProfile?
  gatekeeperLogs GatekeeperLog[]

  // Cognitive OS (NEW)
  employeeGaps EmployeeGap[]
  simulationSessions SimulationSession[]

  // Reminders (NEW)
  reminders Reminder[]

  // Knowledge (NEW - assignee)
  assignedNodes KnowledgeNode[] @relation("NodeAssignee")

  @@unique([companyId, email])
  @@map("users")
}

model CompanySettings {
  id String @id @default(uuid())
  companyId String @unique
  industry String?
  enabledModules String[]
  customSkillCategories String[]
  zettelAutoGeneration Json?
  aiSettings Json?
  crmSettings Json?
  erpSettings Json?
  notificationSettings Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  
  @@map("company_settings")
}

// ============================================
// KNOWLEDGE GRAPH
// ============================================

model KnowledgeNode {
  id String @id @default(uuid())
  companyId String
  title String
  content String @db.Text
  nodeType String // Expandido: NEGOTIATION, CLIENT, PROJECT, DECISION, TASK, SOP, PLAYBOOK, LEARNING, GAP, RCA, CAUSE, EFFECT, DOCUMENT
  tags String[]
  importanceScore Float @default(0.5)
  accessCount Int @default(0)
  createdById String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
  metadata Json?

  // NEW FIELDS (Zettelkasten Inteligente)
  sourceType String? // "conversation", "message", "deal", "file", "interaction", "os"
  sourceId String? // ID da fonte
  assigneeId String? // Responsável
  dueDate DateTime? // Para TASK
  priority String? // LOW, MEDIUM, HIGH, URGENT (para TASK)
  truthStatus String? // DRAFT, ACTIVE, SOURCE_OF_TRUTH, OUTDATED, CONFLICTING, ARCHIVED
  freshnessScore Float? // Score de atualidade (0-1)
  reviewedAt DateTime? // Última revisão
  visibility String @default("COMPANY") // PRIVATE, TEAM, COMPANY
  entities Json? // {contactId, dealId, projectId, osId}

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  createdBy User @relation(fields: [createdById], references: [id])
  assignee User? @relation("NodeAssignee", fields: [assigneeId], references: [id])
  outgoingLinks KnowledgeLink[] @relation("SourceNode")
  incomingLinks KnowledgeLink[] @relation("TargetNode")
  embeddings KnowledgeEmbedding[]
  suggestions KnowledgeSuggestion[]
  reminders Reminder[]

  @@map("knowledge_nodes")
  @@index([companyId])
  @@index([nodeType])
  @@index([sourceType, sourceId])
  @@index([assigneeId])
  @@index([truthStatus])
}

model KnowledgeLink {
  id String @id @default(uuid())
  companyId String
  sourceId String
  targetId String
  linkType String
  strength Float @default(1.0)
  createdAt DateTime @default(now())
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  source KnowledgeNode @relation("SourceNode", fields: [sourceId], references: [id], onDelete: Cascade)
  target KnowledgeNode @relation("TargetNode", fields: [targetId], references: [id], onDelete: Cascade)
  
  @@unique([sourceId, targetId, linkType])
  @@map("knowledge_links")
}

model KnowledgeEmbedding {
  id String @id @default(uuid())
  companyId String
  nodeId String
  embeddingModel String
  vectorId String
  createdAt DateTime @default(now())
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  node KnowledgeNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  
  @@unique([nodeId, embeddingModel])
  @@map("knowledge_embeddings")
}

model KnowledgeSuggestion {
  id String @id @default(uuid())
  companyId String
  nodeId String
  suggestedNodeId String
  userId String
  reason String
  score Float
  accepted Boolean?
  createdAt DateTime @default(now())
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  node KnowledgeNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
  
  @@map("knowledge_suggestions")
}

// ============================================
// SKILLS & LEARNING
// ============================================

model Skill {
  id String @id @default(uuid())
  companyId String
  name String
  category String
  description String?
  createdAt DateTime @default(now())
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employeeSkills EmployeeSkill[]
  
  @@unique([companyId, name])
  @@map("skills")
}

model EmployeeSkill {
  id String @id @default(uuid())
  userId String
  skillId String
  proficiency Int
  lastAssessed DateTime?
  createdAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  skill Skill @relation(fields: [skillId], references: [id], onDelete: Cascade)
  
  @@unique([userId, skillId])
  @@map("employee_skills")
}

model LearningPath {
  id String @id @default(uuid())
  companyId String
  title String
  description String?
  category String
  difficulty String
  estimatedHours Int
  targetSkills String[]
  createdBy String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  items LearningPathItem[]
  enrollments LearningEnrollment[]
  
  @@map("learning_paths")
}

model LearningPathItem {
  id String @id @default(uuid())
  pathId String
  order Int
  contentType String
  title String
  description String?
  contentUrl String?
  estimatedMinutes Int
  required Boolean
  
  path LearningPath @relation(fields: [pathId], references: [id], onDelete: Cascade)
  progresses LearningProgress[]
  
  @@map("learning_path_items")
}

model LearningEnrollment {
  id String @id @default(uuid())
  userId String
  pathId String
  status String @default("enrolled")
  progress Float @default(0)
  enrolledAt DateTime @default(now())
  completedAt DateTime?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  path LearningPath @relation(fields: [pathId], references: [id], onDelete: Cascade)
  
  @@unique([userId, pathId])
  @@map("learning_enrollments")
}

model LearningProgress {
  id String @id @default(uuid())
  userId String
  itemId String
  status String @default("not_started")
  completedAt DateTime?
  timeSpent Int @default(0)
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  item LearningPathItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  
  @@unique([userId, itemId])
  @@map("learning_progress")
}

model SkillDevelopmentPlan {
  id String @id @default(uuid())
  companyId String
  userId String
  skillId String
  currentLevel Int
  targetLevel Int
  deadline DateTime
  status String @default("planning")
  learningPathIds String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, skillId])
  @@map("skill_development_plans")
}

// ============================================
// CRM
// ============================================

model Contact {
  id String @id @default(uuid())
  companyId String
  name String
  email String?
  phone String?
  companyName String?
  position String?
  website String?
  address String?
  city String?
  state String?
  country String?
  zipCode String?
  tags String[]
  customFields Json?
  ownerId String?
  leadSource String?
  leadStatus String?
  rating Int?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  lastContactedAt DateTime?
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  owner User? @relation("ContactOwner", fields: [ownerId], references: [id])
  deals Deal[]
  interactions Interaction[]
  
  @@unique([companyId, email])
  @@map("contacts")
  @@index([companyId, leadStatus])
}

model Deal {
  id String @id @default(uuid())
  companyId String
  title String
  contactId String
  value Float
  currency String @default("USD")
  stage String @default("lead")
  probability Int?
  expectedCloseDate DateTime?
  closedDate DateTime?
  wonReason String? @db.Text
  lostReason String? @db.Text
  ownerId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  contact Contact @relation(fields: [contactId], references: [id])
  owner User @relation("DealOwner", fields: [ownerId], references: [id])
  products DealProduct[]
  interactions Interaction[]
  
  @@map("deals")
  @@index([companyId, stage])
}

model DealProduct {
  id String @id @default(uuid())
  dealId String
  productId String
  productName String
  quantity Int
  unitPrice Float
  discount Float @default(0)
  tax Float @default(0)
  total Float
  
  deal Deal @relation(fields: [dealId], references: [id], onDelete: Cascade)
  
  @@map("deal_products")
}

model Interaction {
  id String @id @default(uuid())
  companyId String
  type String
  contactId String?
  dealId String?
  userId String
  subject String?
  content String @db.Text
  direction String?
  duration Int?
  sentiment String?
  timestamp DateTime @default(now())
  scheduledFor DateTime?
  completedAt DateTime?
  metadata Json?
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  contact Contact? @relation(fields: [contactId], references: [id], onDelete: Cascade)
  deal Deal? @relation(fields: [dealId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
  
  @@map("interactions")
  @@index([companyId, contactId])
  @@index([companyId, dealId])
}

// ============================================
// ERP
// ============================================

model Product {
  id String @id @default(uuid())
  companyId String
  sku String
  name String
  description String? @db.Text
  category String?
  subcategory String?
  unitPrice Float
  costPrice Float?
  stock Int @default(0)
  minStock Int?
  maxStock Int?
  unit String?
  isActive Boolean @default(true)
  imageUrl String?
  barcode String?
  supplierId String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  movements StockMovement[]
  
  @@unique([companyId, sku])
  @@map("products")
}

model StockMovement {
  id String @id @default(uuid())
  productId String
  type String
  quantity Int
  reason String?
  referenceType String?
  referenceId String?
  previousStock Int
  newStock Int
  cost Float?
  userId String
  notes String?
  timestamp DateTime @default(now())
  
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
  
  @@map("stock_movements")
  @@index([productId])
}

model Supplier {
  id String @id @default(uuid())
  companyId String
  name String
  legalName String?
  taxId String?
  email String?
  phone String?
  website String?
  address String?
  city String?
  state String?
  country String?
  zipCode String?
  contactPerson String?
  contactEmail String?
  contactPhone String?
  paymentTerms String?
  deliveryTime Int?
  rating Int?
  notes String? @db.Text
  isActive Boolean @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  
  @@map("suppliers")
}

model Invoice {
  id String @id @default(uuid())
  companyId String
  number String
  contactId String?
  dealId String?
  type String
  status String @default("draft")
  issueDate DateTime @default(now())
  dueDate DateTime
  subtotal Float
  taxAmount Float @default(0)
  discountAmount Float @default(0)
  total Float
  paidAmount Float @default(0)
  paidDate DateTime?
  paymentMethod String?
  notes String? @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  items InvoiceItem[]
  
  @@unique([companyId, number])
  @@map("invoices")
}

model InvoiceItem {
  id String @id @default(uuid())
  invoiceId String
  productId String?
  description String
  quantity Int
  unitPrice Float
  taxRate Float @default(0)
  discountRate Float @default(0)
  total Float
  
  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  
  @@map("invoice_items")
}

model Expense {
  id String @id @default(uuid())
  companyId String
  userId String
  category String
  subcategory String?
  description String
  amount Float
  currency String @default("USD")
  date DateTime @default(now())
  status String @default("pending")
  receipt String?
  projectId String?
  approvedBy String?
  approvedAt DateTime?
  reimbursedAt DateTime?
  notes String? @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
  
  @@map("expenses")
  @@index([companyId, userId])
}

// ============================================
// CHAT
// ============================================

model Channel {
  id String @id @default(uuid())
  companyId String
  name String
  description String?
  type String @default("public")
  createdBy String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  archivedAt DateTime?
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  members ChannelMember[]
  messages Message[]
  
  @@map("channels")
}

model ChannelMember {
  id String @id @default(uuid())
  companyId String
  channelId String
  userId String
  role String @default("member")
  joinedAt DateTime @default(now())
  lastReadAt DateTime?
  
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
  
  @@unique([channelId, userId])
  @@map("channel_members")
}

model DirectConversation {
  id String @id @default(uuid())
  companyId String
  createdAt DateTime @default(now())
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  members DirectConversationMember[]
  messages Message[]
  
  @@map("direct_conversations")
}

model DirectConversationMember {
  id String @id @default(uuid())
  conversationId String
  userId String
  lastReadAt DateTime?
  
  conversation DirectConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
  
  @@unique([conversationId, userId])
  @@map("direct_conversation_members")
}

model Message {
  id String @id @default(uuid())
  companyId String
  channelId String?
  directConversationId String?
  authorId String
  content String @db.Text
  status String @default("sent")
  editedAt DateTime?
  deletedAt DateTime?
  createdAt DateTime @default(now())
  parentMessageId String?
  metadata Json?
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  channel Channel? @relation(fields: [channelId], references: [id], onDelete: Cascade)
  directConversation DirectConversation? @relation(fields: [directConversationId], references: [id], onDelete: Cascade)
  author User @relation(fields: [authorId], references: [id])
  reactions MessageReaction[]
  threads MessageThread[] @relation("ParentMessage")
  threadMessages MessageThread[] @relation("ThreadMessage")
  
  @@map("messages")
  @@index([companyId, channelId])
  @@index([companyId, directConversationId])
}

model MessageReaction {
  id String @id @default(uuid())
  companyId String
  messageId String
  userId String
  emoji String
  createdAt DateTime @default(now())
  
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
  
  @@unique([messageId, userId, emoji])
  @@map("message_reactions")
}

model MessageThread {
  id String @id @default(uuid())
  parentMessageId String
  messageId String
  
  parentMessage Message @relation("ParentMessage", fields: [parentMessageId], references: [id], onDelete: Cascade)
  message Message @relation("ThreadMessage", fields: [messageId], references: [id], onDelete: Cascade)
  
  @@unique([parentMessageId, messageId])
  @@map("message_threads")
}

// ============================================
// OMNICHANNEL - WHATSAPP
// ============================================

model WhatsAppAccount {
  id String @id @default(uuid())
  companyId String
  name String
  instanceName String
  apiUrl String
  apiKey String
  webhookUrl String?
  status String @default("disconnected")
  qrCode String? @db.Text
  lastConnectedAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  sessions WhatsAppSession[]
  contacts WhatsAppContact[]
  conversations WhatsAppConversation[]
  
  @@unique([companyId, instanceName])
  @@map("whatsapp_accounts")
}

model WhatsAppSession {
  id String @id @default(uuid())
  accountId String
  sessionData Json
  expiresAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  account WhatsAppAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  @@map("whatsapp_sessions")
}

model WhatsAppContact {
  id String @id @default(uuid())
  accountId String
  phoneNumber String
  name String?
  profilePicUrl String?
  isGroup Boolean @default(false)
  metadata Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  account WhatsAppAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  conversations WhatsAppConversation[]
  messages WhatsAppMessage[]
  
  @@unique([accountId, phoneNumber])
  @@map("whatsapp_contacts")
}

model WhatsAppConversation {
  id String @id @default(uuid())
  accountId String
  contactId String
  lastMessageAt DateTime?
  unreadCount Int @default(0)
  metadata Json?
  
  account WhatsAppAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  contact WhatsAppContact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  messages WhatsAppMessage[]
  
  @@unique([accountId, contactId])
  @@map("whatsapp_conversations")
}

model WhatsAppMessage {
  id String @id @default(uuid())
  conversationId String
  contactId String
  externalId String
  direction String
  type String
  content String? @db.Text
  mediaUrl String?
  status String @default("pending")
  timestamp DateTime
  metadata Json?
  
  conversation WhatsAppConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  contact WhatsAppContact @relation(fields: [contactId], references: [id])
  
  @@unique([conversationId, externalId])
  @@map("whatsapp_messages")
  @@index([conversationId])
}

// ============================================
// OMNICHANNEL - GENERIC CONVERSATIONS
// ============================================

model Conversation {
  id String @id @default(uuid())
  companyId String
  channel String
  channelAccountId String?
  externalId String?
  contactName String?
  contactPhone String?
  contactEmail String?
  status String @default("open")
  priority String @default("normal")
  subject String?
  tags String[]
  firstResponseAt DateTime?
  lastMessageAt DateTime?
  closedAt DateTime?
  slaBreachAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  metadata Json?
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  assignments ConversationAssignment[]
  notes ConversationNote[]
  tags_relation ConversationTag[]
  slaEvents SLAEvent[]
  csatSurveys CSATSurvey[]
  
  @@map("conversations")
  @@index([companyId, status])
  @@index([companyId, channel])
}

model ConversationAssignment {
  id String @id @default(uuid())
  companyId String
  conversationId String
  userId String
  assignedAt DateTime @default(now())
  unassignedAt DateTime?
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
  
  @@map("conversation_assignments")
  @@index([conversationId])
}

model ConversationTag {
  id String @id @default(uuid())
  conversationId String
  tag String
  createdAt DateTime @default(now())
  
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@unique([conversationId, tag])
  @@map("conversation_tags")
}

model ConversationNote {
  id String @id @default(uuid())
  conversationId String
  userId String
  content String @db.Text
  isInternal Boolean @default(true)
  createdAt DateTime @default(now())
  
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
  
  @@map("conversation_notes")
}

model SLAEvent {
  id String @id @default(uuid())
  conversationId String
  eventType String
  targetTime DateTime
  actualTime DateTime?
  breached Boolean @default(false)
  
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@map("sla_events")
}

model CSATSurvey {
  id String @id @default(uuid())
  conversationId String
  score Int?
  comment String? @db.Text
  sentAt DateTime @default(now())
  respondedAt DateTime?
  
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@map("csat_surveys")
}

// ============================================
// SYNC/INTEGRATIONS
// ============================================

model IntegrationConnection {
  id String @id @default(uuid())
  companyId String
  provider String
  status String @default("disconnected")
  authData Json
  config Json?
  lastSyncAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  
  @@unique([companyId, provider])
  @@map("integration_connections")
}

model ExternalEntityMap {
  id String @id @default(uuid())
  companyId String
  provider String
  entityType String
  externalId String
  internalId String
  fingerprint String?
  lastSeenAt DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  
  @@unique([companyId, provider, entityType, externalId])
  @@map("external_entity_maps")
}

model SyncRun {
  id String @id @default(uuid())
  companyId String
  provider String
  direction String
  entityTypes String[]
  startedAt DateTime @default(now())
  finishedAt DateTime?
  status String @default("running")
  stats Json?
  error String? @db.Text
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  logs SyncJobLog[]
  
  @@map("sync_runs")
}

model SyncJobLog {
  id String @id @default(uuid())
  runId String
  entityType String
  action String
  externalId String?
  internalId String?
  result String
  error String? @db.Text
  createdAt DateTime @default(now())
  
  run SyncRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  
  @@map("sync_job_logs")
}

model DeadLetterQueue {
  id String @id @default(uuid())
  companyId String
  provider String
  jobName String
  payload Json
  error String @db.Text
  attempts Int @default(0)
  nextRetryAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("dead_letter_queue")
}

model WebhookEventLog {
  id String @id @default(uuid())
  provider String
  eventType String
  eventId String
  payload Json
  processed Boolean @default(false)
  processedAt DateTime?
  error String? @db.Text
  createdAt DateTime @default(now())
  
  @@unique([provider, eventId])
  @@map("webhook_event_logs")
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id String @id @default(uuid())
  companyId String
  userId String
  type String
  title String
  body String
  data Json?
  readAt DateTime?
  createdAt DateTime @default(now())
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
  
  @@map("notifications")
  @@index([companyId, userId, readAt])
}

// ============================================
// ANALYTICS
// ============================================

model EventLog {
  id String @id @default(uuid())
  companyId String
  actorId String?
  name String
  entityType String?
  entityId String?
  data Json?
  createdAt DateTime @default(now())
  
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  actor User? @relation(fields: [actorId], references: [id])
  
  @@map("event_logs")
  @@index([companyId, name])
  @@index([companyId, createdAt])
}

// ============================================
// FILE STORAGE
// ============================================

model File {
  id            String   @id @default(uuid())
  companyId     String
  company       Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  uploadedById  String
  uploadedBy    User     @relation(fields: [uploadedById], references: [id])
  filename      String
  objectName    String   // MinIO object name
  mimeType      String
  size          Int
  entityType    String?  // Type of entity (contact, deal, etc)
  entityId      String?  // ID of entity
  createdAt     DateTime @default(now())

  @@index([companyId])
  @@index([entityType, entityId])
  @@map("files")
}

// ============================================
// AUDIT TRAIL
// ============================================

model AuditLog {
  id         String   @id @default(uuid())
  companyId  String
  company    Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  userId     String
  user       User     @relation(fields: [userId], references: [id])
  action     String   // create, update, delete, etc
  entityType String   // contact, deal, user, etc
  entityId   String?
  oldValue   Json?
  newValue   Json?
  metadata   Json?    // IP, user agent, etc
  createdAt  DateTime @default(now())

  @@index([companyId])
  @@index([userId])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("audit_logs")
}

// ============================================
// OAUTH / SSO
// ============================================

model OAuthAccount {
  id             String   @id @default(uuid())
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider       String   // google, microsoft, github
  providerUserId String
  accessToken    String
  refreshToken   String?
  expiresAt      DateTime?
  lastUsedAt     DateTime?
  createdAt      DateTime @default(now())

  @@unique([provider, providerUserId])
  @@index([userId])
  @@map("oauth_accounts")
}

model OAuthState {
  state     String   @id
  provider  String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([expiresAt])
  @@map("oauth_states")
}

// ============================================
// WEBHOOKS OUTGOING
// ============================================

model WebhookSubscription {
  id          String             @id @default(uuid())
  companyId   String
  company     Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
  url         String
  events      String[]           // Array of event names
  secret      String
  description String?
  active      Boolean            @default(true)
  deliveries  WebhookDelivery[]
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@index([companyId])
  @@map("webhook_subscriptions")
}

model WebhookDelivery {
  id             String              @id @default(uuid())
  subscriptionId String
  subscription   WebhookSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  deliveryId     String              @unique
  event          String
  payload        Json
  statusCode     Int?
  responseBody   Json?
  error          String?
  success        Boolean
  attemptNumber  Int
  createdAt      DateTime            @default(now())

  @@index([subscriptionId])
  @@index([createdAt])
  @@map("webhook_deliveries")
}

// ============================================
// API KEYS
// ============================================

model ApiKey {
  id          String            @id @default(uuid())
  companyId   String
  company     Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  createdById String
  createdBy   User              @relation("ApiKeyCreator", fields: [createdById], references: [id])
  name        String
  keyHash     String            @unique
  prefix      String            // First 12 chars for identification
  scopes      String[]          // Array of scopes/permissions
  lastUsedAt  DateTime?
  expiresAt   DateTime?
  revoked     Boolean           @default(false)
  usageLogs   ApiKeyUsageLog[]
  createdAt   DateTime          @default(now())

  @@index([companyId])
  @@index([keyHash])
  @@map("api_keys")
}

model ApiKeyUsageLog {
  id        String   @id @default(uuid())
  apiKeyId  String
  apiKey    ApiKey   @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)
  endpoint  String
  method    String
  ipAddress String
  userAgent String
  timestamp DateTime @default(now())

  @@index([apiKeyId])
  @@index([timestamp])
  @@map("api_key_usage_logs")
}

// ============================================
// AUTOMATIONS / WORKFLOW ENGINE
// ============================================

model Workflow {
  id          String   @id @default(uuid())
  companyId   String
  name        String
  description String?
  version     Int      @default(1)
  status      String   @default("DRAFT") // DRAFT, ACTIVE, PAUSED, ARCHIVED
  definition  Json     // nodes + edges
  createdBy   String
  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())

  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  executions  WorkflowExecution[]

  @@index([companyId, status])
  @@map("workflows")
}

model WorkflowExecution {
  id          String   @id @default(uuid())
  workflowId  String
  status      String   // RUNNING, COMPLETED, FAILED, CANCELLED
  startedAt   DateTime @default(now())
  finishedAt  DateTime?
  context     Json     // Input context
  logs        Json[]   // Execution logs
  error       String?  @db.Text

  workflow    Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  @@index([workflowId, status])
  @@index([startedAt])
  @@map("workflow_executions")
}

// ============================================
// GATEKEEPER AGENT
// ============================================

model AttentionProfile {
  id          String   @id @default(uuid())
  userId      String   @unique
  level       String   @default("BALANCED") // SILENT, BALANCED, ACTIVE
  quietHours  Json     // [{start: "22:00", end: "08:00", days: [0,6], timezone: "America/Sao_Paulo"}]
  channels    Json     // {email: true, push: true, inapp: true, whatsapp: false, sms: false}
  vipList     Json     // {contacts: [], projects: [], deals: []}
  autonomy    Json     // {create_zettel: "EXECUTE", send_message: "SUGGEST", ...}
  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("attention_profiles")
}

model CompanyPolicy {
  id          String   @id @default(uuid())
  companyId   String   @unique
  maxAutonomy Json     // {viewer: {...}, agent: {...}, supervisor: {...}, admin: {...}}
  forbidden   Json     // ["send_external_message_auto", "delete_contact_auto"]
  auditRules  Json     // {retention_days: 365, immutable: true, export_allowed: false}
  rateLimits  Json     // {ai_calls_per_user_per_day: 100, ai_calls_per_company_per_day: 1000}
  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())

  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("company_policies")
}

model GatekeeperLog {
  id          String   @id @default(uuid())
  companyId   String
  userId      String?
  action      String   // "send_notification", "create_zettel", "send_message", etc
  decision    String   // EXECUTE, SUGGEST, LOG_ONLY, BLOCK
  reason      String   @db.Text
  context     Json     // Full context of the decision
  timestamp   DateTime @default(now())

  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user        User?    @relation(fields: [userId], references: [id])

  @@index([companyId, timestamp])
  @@index([userId, timestamp])
  @@index([action])
  @@map("gatekeeper_logs")
}

// ============================================
// REMINDERS (Zettelkasten)
// ============================================

model Reminder {
  id              String   @id @default(uuid())
  companyId       String
  nodeId          String
  userId          String
  type            String   // FOLLOW_UP, TASK_DUE, REVIEW_REQUIRED, COMMITMENT
  scheduledFor    DateTime
  status          String   @default("PENDING") // PENDING, SENT, SNOOZED, DISMISSED, COMPLETED
  message         String   @db.Text
  snoozedUntil    DateTime?
  sentAt          DateTime?
  dismissedAt     DateTime?
  completedAt     DateTime?
  createdAt       DateTime @default(now())
  metadata        Json?

  company         Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  node            KnowledgeNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([scheduledFor, status])
  @@index([userId, status])
  @@index([nodeId])
  @@map("reminders")
}

// ============================================
// COGNITIVE OS - PEOPLE GROWTH
// ============================================

model EmployeeGap {
  id          String   @id @default(uuid())
  companyId   String
  employeeId  String
  skillId     String?
  domain      String   // COMMERCIAL, TECHNICAL, MANAGEMENT, SOFT_SKILLS
  gap         String   @db.Text // Descrição do gap
  evidence    Json[]   // [{nodeId, conversationId, dealId, interactionId, type}]
  severity    String   // LOW, MEDIUM, HIGH, CRITICAL
  status      String   @default("OPEN") // OPEN, IN_PROGRESS, CLOSED
  closedAt    DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  metadata    Json?

  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employee    User     @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([employeeId, status])
  @@index([companyId, domain])
  @@index([severity])
  @@map("employee_gaps")
}

// ============================================
// SIMULATION ENGINE
// ============================================

model SimulationScenario {
  id                String   @id @default(uuid())
  companyId         String
  title             String
  description       String   @db.Text
  type              String   // NEGOTIATION, OBJECTION, TECHNICAL, CRISIS, ONBOARDING
  persona           Json     // Definição da persona simulada
  rubric            Json     // Critérios de avaliação
  difficulty        Int      // 1-5
  estimatedDuration Int      // minutos
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  metadata          Json?

  company           Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  sessions          SimulationSession[]

  @@index([companyId, type])
  @@map("simulation_scenarios")
}

model SimulationSession {
  id          String   @id @default(uuid())
  scenarioId  String
  userId      String
  startedAt   DateTime @default(now())
  finishedAt  DateTime?
  transcript  Json[]   // [{role: "user"|"persona", content: "...", timestamp: "..."}]
  evaluation  Json?    // {score, strengths, improvements, gaps, nextSteps}
  score       Float?   // 0-100
  feedback    String?  @db.Text

  scenario    SimulationScenario @relation(fields: [scenarioId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([scenarioId])
  @@map("simulation_sessions")
}
